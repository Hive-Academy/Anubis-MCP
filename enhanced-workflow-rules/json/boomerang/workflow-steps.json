{
  "workflowSteps": [
    {
      "name": "mandatory_git_integration_setup",
      "displayName": "MANDATORY: Git Integration Setup",
      "description": "CRITICAL: Complete Git operations before task creation. STOP workflow if any step fails.",
      "sequenceNumber": 1,
      "isRequired": true,
      "estimatedTime": "2-4 minutes",
      "stepType": "ACTION",
      "behavioralContext": {
        "approach": "Mandatory git state verification and feature branch creation",
        "principles": [
          "NEVER proceed with dirty git state, always commit or stash changes before proceeding based on user input",
          "Always create feature branch for new work, if user wants to continue working on existing task, use the same branch",
          "Follow strict git workflow protocols",
          "STOP workflow immediately if git operations fail"
        ],
        "methodology": "Git-first workflow with mandatory verification and branch creation",
        "gitOperations": {
          "stateVerification": "Verify clean working directory using 'git status --porcelain' (should return empty)",
          "repositoryValidation": "Verify git repository and remote configuration using 'git rev-parse --git-dir' and 'git remote -v'",
          "updateProcess": "Fetch latest changes from origin using 'git fetch origin'",
          "branchCreation": "Create feature branch with naming convention: feature/TSK-XXX-description",
          "verification": "Verify branch creation using 'git branch --show-current'"
        },
        "errorHandling": {
          "dirtyState": "CRITICAL: Git state is not clean. Commit or stash changes before proceeding.",
          "noRepository": "CRITICAL: Not a valid git repository.",
          "noRemotes": "CRITICAL: No git remotes configured.",
          "fetchFailure": "CRITICAL: Failed to fetch from origin.",
          "branchFailure": "CRITICAL: Failed to create feature branch.",
          "verificationFailure": "CRITICAL: Branch creation verification failed."
        }
      },
      "approachGuidance": {
        "stepByStep": [
          "Verify clean working directory using git status --porcelain",
          "Handle uncommitted changes if present (stash, commit, or clean based on user input)",
          "Verify repository and remote configuration using git commands",
          "Fetch latest changes from origin with timeout handling",
          "Create feature branch with naming convention: feature/TSK-XXX-description",
          "Verify branch creation and document branch name for task context"
        ],
        "commandSequence": [
          "git status --porcelain (expect empty output)",
          "git rev-parse --git-dir (verify repository)",
          "git remote -v (verify remotes configured)",
          "git fetch origin (update from remote)",
          "git checkout -b feature/TSK-{{task_id}}-{{task_slug}}",
          "git branch --show-current (verify branch creation)"
        ],
        "validationSteps": [
          "Confirm git status returns empty (clean state)",
          "Confirm repository directory exists and is valid",
          "Confirm at least one remote is configured",
          "Confirm fetch completes without errors",
          "Confirm branch creation succeeds",
          "Confirm current branch matches expected feature branch name"
        ]
      },
      "qualityChecklist": [
        "Git status is completely clean (no uncommitted changes)",
        "Repository and remote configuration validated",
        "Latest changes fetched successfully",
        "Feature branch created with proper naming convention",
        "Branch creation verified and documented",
        "All git operations completed without errors"
      ],
      "conditions": [
        {
          "name": "git_available",
          "conditionType": "COMMAND_AVAILABLE",
          "logic": {
            "check": "command_exists",
            "parameters": {
              "command": "git",
              "requiredVersion": "2.0.0"
            }
          },
          "isRequired": true
        }
      ],
      "actions": [],
      "triggerReport": true,
      "reportType": "git_setup",
      "reportTemplate": "git_integration_setup"
    },
    {
      "name": "mandatory_source_code_analysis_with_functional_verification",
      "displayName": "MANDATORY: Source Code Analysis with Functional Verification",
      "description": "Systematic codebase examination WITH functional testing to verify actual behavior",
      "sequenceNumber": 2,
      "isRequired": true,
      "estimatedTime": "8-12 minutes",
      "stepType": "ANALYSIS",
      "behavioralContext": {
        "approach": "Comprehensive codebase analysis combined with functional verification testing",
        "principles": [
          "Never make assumptions about current system state",
          "Always test actual functionality before decisions",
          "Document evidence-based findings",
          "Verify capabilities through hands-on investigation"
        ],
        "methodology": "Multi-phase analysis: structural, functional verification, and quality assessment",
        "analysisPhases": {
          "structuralAnalysis": "Identify implementation patterns, technology stack, integration patterns, and component interactions",
          "functionalVerification": "Test current functionality, existing features, validate capabilities, and test assumptions",
          "qualityAssessment": "Review error handling, testing patterns, performance considerations, and security implementations",
          "evidenceDocumentation": "Document file locations, testing results, current capabilities, and identified gaps"
        },
        "verificationMethods": {
          "patternIdentification": "Study similar feature implementations with concrete examples",
          "technologyMapping": "Document technology stack components and versions",
          "functionalTesting": "Execute existing features to understand actual capabilities",
          "assumptionValidation": "Test assumptions through actual code execution and testing",
          "capabilityVerification": "Verify system capabilities through hands-on investigation"
        }
      },
      "approachGuidance": {
        "stepByStep": [
          "Identify implementation patterns relevant to current task",
          "Document technology stack components and versions",
          "Study similar feature implementations with examples",
          "Test current functionality using available tools",
          "Execute existing features to understand capabilities",
          "Validate assumptions through actual testing",
          "Review error handling and validation approaches",
          "Document comprehensive findings with evidence"
        ],
        "analysisSteps": [
          "Examine project structure and identify key directories and files",
          "Map technology stack including frameworks, libraries, and versions",
          "Find and analyze similar implementations for patterns and approaches",
          "Test existing functionality to understand current system behavior"
        ],
        "verificationSteps": [
          "Execute existing features to verify actual capabilities",
          "Test edge cases and error conditions to understand system limits",
          "Validate technical assumptions through direct testing",
          "Document evidence from testing and verification activities"
        ],
        "documentationSteps": [
          "Record file locations and implementation patterns discovered",
          "Document testing results and verification evidence",
          "Catalog current capabilities and system limitations",
          "Identify gaps between requirements and current capabilities"
        ]
      },
      "qualityChecklist": [
        "Implementation patterns identified and documented",
        "Technology stack components and versions recorded",
        "Similar feature implementations analyzed with examples",
        "Current functionality tested with evidence collected",
        "Assumptions validated through actual testing",
        "Error handling and validation approaches reviewed",
        "Comprehensive findings documented with evidence",
        "Functional verification results documented"
      ],
      "conditions": [
        {
          "name": "codebase_accessible",
          "conditionType": "DIRECTORY_EXISTS",
          "logic": {
            "check": "directory_exists",
            "parameters": {
              "directories": ["src", "lib", "app"]
            }
          },
          "isRequired": true
        }
      ],
      "actions": [],
      "triggerReport": true,
      "reportType": "functional_verification",
      "reportTemplate": "source_code_analysis_with_verification"
    },
    {
      "name": "mandatory_comprehensive_task_creation",
      "displayName": "MANDATORY: Create Task with Comprehensive Data",
      "description": "Create the task with comprehensive data using execution context and codebase analysis",
      "sequenceNumber": 3,
      "isRequired": true,
      "estimatedTime": "5-8 minutes",
      "stepType": "ACTION",
      "behavioralContext": {
        "approach": "Create task with comprehensive data using stored execution context and codebase analysis",
        "principles": [
          "Read task creation data from workflow execution context (stored by bootstrap)",
          "Create task with comprehensive description, requirements, and codebase analysis",
          "Store comprehensive codebase analysis for downstream roles",
          "Document functional verification results",
          "Link task to existing workflow execution"
        ],
        "methodology": "Task creation with MCP-driven comprehensive data integration and analysis storage",
        "creationStrategy": {
          "contextRetrieval": "Retrieve task creation data from workflow execution taskCreationData",
          "taskCreation": "Create task with comprehensive description and requirements from context",
          "analysisIntegration": "Structure codebase analysis findings for downstream consumption",
          "verificationStorage": "Include functional verification results and evidence",
          "executionLinking": "Link created task to existing workflow execution",
          "contextUpdate": "Update execution context to mark task as created"
        }
      },
      "approachGuidance": {
        "stepByStep": [
          "Retrieve task creation data from workflow execution taskCreationData",
          "Generate unique slug from task name",
          "Create task with comprehensive description and requirements",
          "Structure codebase analysis findings for downstream consumption",
          "Include functional verification results and evidence",
          "Store git branch information and context",
          "Link task to workflow execution",
          "Update execution context to mark task as created"
        ],
        "dataRetrievalSteps": [
          "Call WorkflowOperations.get_execution_context to get taskCreationData",
          "Extract task name, description, requirements, and acceptance criteria",
          "Get current execution ID for linking",
          "Prepare comprehensive task creation data structure"
        ],
        "creationSteps": [
          "Generate unique slug from task name",
          "Call TaskOperations.create with comprehensive data",
          "Include codebase analysis results in structured format",
          "Add functional verification evidence and results",
          "Update git branch information and metadata"
        ],
        "linkingSteps": [
          "Update WorkflowExecution with created task ID",
          "Call WorkflowOperations.update_execution_context",
          "Mark task creation as completed",
          "Update timestamps and completion flags",
          "Ensure workflow continuity for next steps"
        ]
      },
      "qualityChecklist": [
        "Task creation data successfully retrieved from execution context",
        "Task created with comprehensive description and requirements",
        "Codebase analysis structured and complete",
        "Functional verification results included",
        "Git branch information recorded",
        "Task linked to workflow execution",
        "Execution context updated to reflect task creation"
      ],
      "conditions": [
        {
          "name": "analysis_completed",
          "conditionType": "PREVIOUS_STEP_COMPLETED",
          "logic": {
            "check": "step_completed",
            "parameters": {
              "stepName": "mandatory_source_code_analysis_with_functional_verification"
            }
          },
          "isRequired": true
        },
        {
          "name": "task_creation_pending",
          "conditionType": "EXECUTION_CONTEXT_CHECK",
          "logic": {
            "check": "execution_context_contains",
            "parameters": {
              "key": "taskCreationPending",
              "expectedValue": true
            }
          },
          "isRequired": true
        }
      ],
      "actions": [
        {
          "name": "retrieve_task_creation_data",
          "actionType": "MCP_CALL",
          "actionData": {
            "serviceName": "WorkflowOperations",
            "operation": "get_execution_context",
            "parameters": {
              "executionId": "{{current_execution_id}}",
              "dataKey": "taskCreationData"
            }
          },
          "sequenceOrder": 1
        },
        {
          "name": "create_task_with_comprehensive_data",
          "actionType": "MCP_CALL",
          "actionData": {
            "serviceName": "TaskOperations",
            "operation": "create",
            "parameters": {
              "name": "{{task_name_from_context}}",
              "slug": "{{generated_unique_slug}}",
              "description": "{{task_description_from_context}}",
              "businessRequirements": "{{business_requirements_from_context}}",
              "technicalRequirements": "{{technical_requirements_from_context}}",
              "acceptanceCriteria": "{{acceptance_criteria_from_context}}",
              "priority": "{{priority_from_context}}",
              "status": "not-started",
              "owner": "boomerang",
              "currentMode": "boomerang",
              "gitBranch": "{{created_feature_branch}}",
              "codebaseAnalysis": {
                "architectureFindings": "{{architecture_analysis_results}}",
                "problemsIdentified": "{{identified_issues_and_debt}}",
                "implementationContext": "{{patterns_and_standards}}",
                "integrationPoints": "{{api_and_service_interfaces}}",
                "qualityAssessment": "{{testing_and_performance_baseline}}",
                "functionalVerification": "{{verification_evidence_and_results}}",
                "gitBranch": "{{created_feature_branch}}",
                "analyzedBy": "boomerang",
                "analysisTimestamp": "{{current_timestamp}}"
              },
              "metadata": {
                "createdFromExecution": true,
                "executionId": "{{current_execution_id}}",
                "comprehensiveCreation": true,
                "creationTimestamp": "{{current_timestamp}}"
              }
            }
          },
          "sequenceOrder": 2
        },
        {
          "name": "link_task_to_execution",
          "actionType": "MCP_CALL",
          "actionData": {
            "serviceName": "WorkflowOperations",
            "operation": "update_execution",
            "parameters": {
              "executionId": "{{current_execution_id}}",
              "updates": {
                "taskId": "{{created_task_id}}",
                "autoCreatedTask": true
              }
            }
          },
          "sequenceOrder": 3
        },
        {
          "name": "update_execution_context",
          "actionType": "MCP_CALL",
          "actionData": {
            "serviceName": "WorkflowOperations",
            "operation": "update_execution_context",
            "parameters": {
              "executionId": "{{current_execution_id}}",
              "contextUpdates": {
                "taskCreationPending": false,
                "taskCreated": true,
                "taskId": "{{created_task_id}}",
                "taskCreationTimestamp": "{{current_timestamp}}"
              }
            }
          },
          "sequenceOrder": 4
        }
      ],
      "triggerReport": true,
      "reportType": "comprehensive_task_creation",
      "reportTemplate": "task_comprehensive_creation_completion"
    },
    {
      "name": "research_decision_framework_with_validation",
      "displayName": "Research Decision Framework with Current State Validation",
      "description": "Evaluate research necessity using verified decision criteria and evidence",
      "sequenceNumber": 4,
      "isRequired": true,
      "estimatedTime": "3-5 minutes",
      "stepType": "ACTION",
      "behavioralContext": {
        "approach": "Evidence-based research decision making with mandatory verification",
        "principles": [
          "Base decisions on verified current state testing",
          "Document evidence supporting research rationale",
          "Use tested capabilities vs assumptions for decisions",
          "Provide specific research questions if research needed"
        ],
        "methodology": "Verification-driven decision matrix with evidence documentation",
        "decisionCriteria": {
          "definitelyResearch": [
            "unfamiliar_technologies_verified",
            "multiple_approaches_needed_confirmed",
            "critical_architecture_decisions_tested",
            "security_requirements_beyond_current",
            "unknown_external_systems_proven"
          ],
          "unlikelyResearch": [
            "clear_implementation_path_confirmed",
            "well_understood_technology_validated",
            "similar_work_completed_verified",
            "standard_operations_tested"
          ]
        },
        "evidenceRequirements": {
          "currentStateTested": "Verify current system capabilities through actual testing",
          "capabilitiesVerified": "Document what the system can and cannot do",
          "limitationsConfirmed": "Test and confirm system limitations",
          "complexityValidated": "Validate complexity assumptions through hands-on investigation",
          "verificationEvidence": "Provide concrete evidence from testing and investigation"
        }
      },
      "approachGuidance": {
        "stepByStep": [
          "Review functional verification results from previous step",
          "Test existing functionality to understand current capabilities",
          "Verify technical claims through actual code execution",
          "Validate complexity assumptions with hands-on investigation",
          "Apply evidence-based decision criteria for research necessity",
          "Document specific research questions if research is needed"
        ],
        "evaluationSteps": [
          "Apply decision matrix criteria to current task requirements",
          "Compare task complexity against verified system capabilities",
          "Assess whether current knowledge is sufficient for implementation",
          "Determine if additional research would provide significant value"
        ],
        "documentationSteps": [
          "Document decision rationale with supporting evidence",
          "Record verification results that influenced the decision",
          "Specify research questions if research is recommended",
          "Prepare context for next role based on decision outcome"
        ]
      },
      "qualityChecklist": [
        "Current state tested and capabilities verified",
        "Technical claims validated through execution",
        "Complexity assumptions tested with evidence",
        "Decision criteria applied with verification evidence",
        "Research decision documented with rationale",
        "Specific research questions provided if research needed"
      ],
      "conditions": [
        {
          "name": "functional_verification_completed",
          "conditionType": "PREVIOUS_STEP_COMPLETED",
          "logic": {
            "check": "step_completed",
            "parameters": {
              "stepName": "mandatory_source_code_analysis_with_functional_verification"
            }
          },
          "isRequired": true
        }
      ],
      "actions": [],
      "triggerReport": true,
      "reportType": "research_decision",
      "reportTemplate": "evidence_based_research_decision"
    },
    {
      "name": "role_delegation_with_task_slug",
      "displayName": "Role Delegation with Task-Slug",
      "description": "Delegate to appropriate role with comprehensive context and human-readable references",
      "sequenceNumber": 5,
      "isRequired": true,
      "estimatedTime": "2-3 minutes",
      "stepType": "ACTION",
      "behavioralContext": {
        "approach": "Context-rich delegation with human-readable task references",
        "principles": [
          "Include task-slug for human-readable reference",
          "Provide comprehensive context handoff",
          "Select appropriate target role based on research decision",
          "Ensure proper workflow continuity"
        ],
        "methodology": "MCP-driven delegation with structured context preservation",
        "delegationStrategy": {
          "roleSelection": "Determine target role based on research decision results (researcher if research needed, architect if direct implementation)",
          "contextPreparation": "Prepare comprehensive delegation context including task-slug and analysis results",
          "handoffExecution": "Execute workflow delegation through MCP operations with full context",
          "continuityEnsurance": "Ensure proper context handoff and workflow continuity"
        }
      },
      "approachGuidance": {
        "stepByStep": [
          "Determine target role based on research decision results",
          "Prepare comprehensive delegation context including task-slug",
          "Execute workflow delegation through MCP operations",
          "Ensure proper context handoff and documentation"
        ],
        "roleSelectionSteps": [
          "Review research decision outcome from previous step",
          "Select researcher role if research is needed",
          "Select architect role if implementation can proceed directly",
          "Prepare role-specific delegation message and context"
        ],
        "delegationSteps": [
          "Call WorkflowOperations.delegate with target role",
          "Include task-slug for human-readable reference",
          "Provide comprehensive handoff message with context",
          "Ensure all analysis results are available to next role"
        ]
      },
      "qualityChecklist": [
        "Target role selected based on evidence-based research decision",
        "Task-slug included for human-readable reference",
        "Comprehensive context prepared for handoff",
        "Delegation executed successfully through MCP",
        "Workflow continuity ensured"
      ],
      "conditions": [
        {
          "name": "research_decision_completed",
          "conditionType": "PREVIOUS_STEP_COMPLETED",
          "logic": {
            "check": "step_completed",
            "parameters": {
              "stepName": "research_decision_framework_with_validation"
            }
          },
          "isRequired": true
        }
      ],
      "actions": [
        {
          "name": "execute_role_delegation",
          "actionType": "MCP_CALL",
          "actionData": {
            "serviceName": "WorkflowOperations",
            "operation": "delegate",
            "parameters": {
              "taskId": "{{task_id}}",
              "taskSlug": "{{task_slug}}",
              "fromRole": "boomerang",
              "toRole": "{{target_role_based_on_research_decision}}",
              "message": "{{focused_delegation_message_with_context}}"
            }
          },
          "sequenceOrder": 1
        }
      ],
      "triggerReport": true,
      "reportType": "delegation",
      "reportTemplate": "role_delegation_with_context"
    }
  ]
}
