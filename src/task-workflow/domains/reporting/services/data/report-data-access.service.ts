/**
 * Report Data Access Service
 *
 * Extracted from the oversized 794-line report-generator.service.ts
 * Handles all database queries and data retrieval logic.
 *
 * Addresses codebase analysis findings:
 * - Scattered data transformation across services
 * - Large service classes (794+ lines)
 * - Complex interdependencies between services
 */

import { Injectable, Logger } from '@nestjs/common';
import {
  ReportType,
  WhereClause,
} from '../../interfaces/service-contracts.interface';
import {
  CodeReviewMetrics,
  DelegationMetrics,
  PerformanceMetrics,
  ReportFilters,
  TaskMetrics,
} from '../../interfaces/report-data.interface';
import { TaskSummaryReportData } from '../../interfaces/task-summary-data.interface';
import { MetricsCalculatorService } from './metrics-calculator.service';

@Injectable()
export class ReportDataAccessService {
  private readonly logger = new Logger(ReportDataAccessService.name);

  constructor(private readonly metricsCalculator: MetricsCalculatorService) {}

  /**
   * Get task summary report data (Legacy method - maintained for backward compatibility)
   * Transforms nested metrics into flat structure expected by task-summary template
   */
  async getTaskSummaryDataLegacy(
    startDate?: Date,
    endDate?: Date,
    filters?: ReportFilters,
  ): Promise<TaskSummaryReportData> {
    this.logger.debug('Generating task summary report data');

    const whereClause = this.buildWhereClause(startDate, endDate, filters);

    // Get base metrics
    const baseMetrics = await this.getBaseMetrics(whereClause);

    // Transform to flat structure expected by template
    const taskSummaryData: TaskSummaryReportData = {
      title: 'Task Summary Report',
      generatedAt: new Date(),
      dateRange: {
        start: startDate?.toISOString().split('T')[0] || 'All time',
        end: endDate?.toISOString().split('T')[0] || 'Present',
      },
      filters: filters || undefined,

      // Flatten metrics structure for template
      metrics: {
        totalTasks: baseMetrics.tasks.totalTasks,
        totalTasksChange: undefined, // TODO: Calculate vs previous period

        completedTasks: baseMetrics.tasks.completedTasks,
        completionRate: Math.round(baseMetrics.tasks.completionRate),

        inProgressTasks: baseMetrics.tasks.inProgressTasks,
        avgTimeInProgress: this.formatDuration(
          baseMetrics.tasks.avgCompletionTimeHours,
        ),

        highPriorityTasks: this.getHighPriorityCount(
          baseMetrics.tasks.priorityDistribution,
        ),
        overdueHighPriority: undefined, // TODO: Calculate overdue high priority tasks
      },

      // Chart data will be generated by ChartCoordinationService
      chartData: {
        statusLabels: ['Completed', 'In Progress', 'Not Started'],
        statusData: [
          baseMetrics.tasks.completedTasks,
          baseMetrics.tasks.inProgressTasks,
          baseMetrics.tasks.notStartedTasks,
        ],
        priorityLabels: baseMetrics.tasks.priorityDistribution.map(
          (p) => p.priority || 'Unknown',
        ),
        priorityData: baseMetrics.tasks.priorityDistribution.map(
          (p) => p.count,
        ),
      },

      // TODO: Add tasks list and insights
      tasks: undefined,
      insights: undefined,
    };

    return taskSummaryData;
  }

  /**
   * Get base metrics for aggregate reports
   * Extracted from report-generator.service.ts
   */
  async getBaseMetrics(whereClause: WhereClause): Promise<{
    tasks: TaskMetrics;
    delegations: DelegationMetrics;
    codeReviews: CodeReviewMetrics;
    performance: PerformanceMetrics;
  }> {
    this.logger.debug('Fetching base metrics for aggregate report');

    const [tasks, delegations, codeReviews, performance] = await Promise.all([
      this.metricsCalculator.getTaskMetrics(whereClause),
      this.metricsCalculator.getDelegationMetrics(whereClause),
      this.metricsCalculator.getCodeReviewMetrics(whereClause),
      this.metricsCalculator.getPerformanceMetrics(whereClause),
    ]);

    return { tasks, delegations, codeReviews, performance };
  }

  /**
   * Get individual task metrics
   * Extracted from report-generator.service.ts
   */
  async getIndividualTaskMetrics(
    reportType: ReportType,
    taskId: string,
  ): Promise<any> {
    this.logger.debug(`Fetching individual task metrics for ${taskId}`);

    const whereClause = { taskId };

    switch (reportType) {
      case 'task_progress_health':
        return await this.metricsCalculator.getTaskProgressHealthMetrics(
          taskId,
        );
      case 'implementation_execution':
        return this.metricsCalculator.getImplementationExecutionMetrics(taskId);
      case 'code_review_quality':
        return this.metricsCalculator.getCodeReviewQualityMetrics(taskId);
      case 'delegation_flow_analysis_task':
        return this.metricsCalculator.getTaskDelegationFlowMetrics(taskId);
      case 'research_documentation':
        return this.metricsCalculator.getResearchDocumentationMetrics(taskId);
      case 'communication_collaboration':
        return this.metricsCalculator.getCommunicationCollaborationMetrics(
          taskId,
        );
      default:
        // Generic task metrics
        return await this.metricsCalculator.getTaskMetrics(whereClause);
    }
  }

  /**
   * Build where clause for database queries
   * Extracted from report-generator.service.ts
   */
  buildWhereClause(
    startDate?: Date,
    endDate?: Date,
    filters?: ReportFilters,
  ): WhereClause {
    const whereClause: WhereClause = {};

    if (startDate && endDate) {
      whereClause.creationDate = {
        gte: startDate,
        lte: endDate,
      };
    }

    if (filters) {
      if (filters.owner) {
        whereClause.owner = filters.owner;
      }
      if (filters.mode) {
        whereClause.currentMode = filters.mode;
      }
      if (filters.priority) {
        whereClause.priority = filters.priority;
      }
      if (filters.taskId) {
        whereClause.taskId = filters.taskId;
      }
    }

    return whereClause;
  }

  /**
   * Check if report type is for individual tasks
   * Extracted from report-generator.service.ts
   */
  isIndividualTaskReport(reportType: ReportType): boolean {
    return [
      'task_progress_health',
      'implementation_execution',
      'code_review_quality',
      'delegation_flow_analysis_task',
      'research_documentation',
      'communication_collaboration',
    ].includes(reportType);
  }

  /**
   * Helper methods for data transformation
   */
  private formatDuration(hours: number): string {
    if (!hours || hours === 0) return 'N/A';
    if (hours < 1) return `${Math.round(hours * 60)}m`;
    if (hours < 24) return `${hours.toFixed(1)}h`;
    return `${Math.round(hours / 24)}d`;
  }

  private getHighPriorityCount(
    priorityDistribution: Array<{ priority: string | null; count: number }>,
  ): number {
    return priorityDistribution
      .filter((p) => p.priority === 'High' || p.priority === 'Critical')
      .reduce((sum, p) => sum + p.count, 0);
  }
}
