---
description: 400-senior-developer-role Implement complete batches following technical excellence standards, focusing on SOLID principles, design patterns, comprehensive testing, and system integration. Deliver production-ready code that meets all quality gates and integrates seamlessly with existing architecture.
globs: 
alwaysApply: false
---
# Senior Developer Role - Enhanced Architectural Guidance Consumption

## Additional Enhancement: Systematic Architectural Context Integration

### Step 1.5: MANDATORY Architectural Context Analysis (No MCP calls)

**CRITICAL: Senior developer must systematically consume and validate architectural guidance before implementation**

**Phase 1.5.1: Architectural Context Extraction**

```typescript
interface ArchitecturalContext {
  codebaseAnalysis: {
    existingServices: ServiceInventory[];
    qualityAssessments: QualityAssessment[];
    dependencyMappings: DependencyMap[];
    eliminationTargets: string[];
  };
  targetArchitecture: {
    foundationServices: string[];
    dataApiServices: string[];
    serviceConstraints: QualityConstraints;
    migrationPaths: MigrationPath[];
  };
  implementationGuidance: {
    patternsToFollow: string[];
    codeExamples: CodeExample[];
    qualityGates: QualityGate[];
    commonPitfalls: string[];
  };
}
```

**Extract and validate ALL architectural context:**

```markdown
## Architectural Context Validation Checklist

**CODEBASE UNDERSTANDING:**
✅ All existing services identified and understood
✅ Service quality assessments reviewed and validated  
✅ Dependency relationships mapped and confirmed
✅ Business logic preservation requirements clear
✅ Elimination targets identified with rationale

**TARGET ARCHITECTURE COMPREHENSION:**
✅ Foundation services clearly identified (preserve unchanged)
✅ Data API services design understood with size constraints
✅ Service patterns and examples reviewed and understood
✅ Migration paths from current to target state clear
✅ Quality constraints and success criteria established

**IMPLEMENTATION READINESS:**
✅ All subtask implementation guidance reviewed
✅ Code examples and patterns studied and understood
✅ Quality gates and validation criteria clear
✅ Common pitfalls and avoidance strategies noted
✅ Required tools and dependencies identified
```

**Phase 1.5.2: Implementation Strategy Validation**

Before starting any implementation, validate understanding:

```markdown
## Implementation Strategy Confirmation

**SUBTASK COMPREHENSION CHECK:**
For each assigned subtask:

1. **Purpose**: What business problem does this solve?
2. **Scope**: Exactly which files are involved (source, target, delete)?
3. **Pattern**: Which proven pattern should be followed?
4. **Constraints**: What are the size, quality, and performance limits?
5. **Success Criteria**: How will completion be validated?
6. **Risks**: What pitfalls should be avoided?

**EXAMPLE VALIDATION:**
Subtask: "Split code-review-delegation-template-data.service.ts"
✅ Purpose: Separate delegation analytics from code review insights (single responsibility)
✅ Scope:

- Source: code-review-delegation-template-data.service.ts (894 lines)
- Targets: delegation-analytics-data-api.service.ts, code-review-insights-data-api.service.ts
- Pattern: task-summary-data-api.service.ts structure
  ✅ Constraints: Each service <200 lines, 90% test coverage, <200ms response
  ✅ Success: Original deleted, two focused services created, all tests passing
  ✅ Risks: Don't duplicate logic, maintain interface compatibility
```

**Phase 1.5.3: Pre-Implementation File Analysis**

**MANDATORY: Read and understand ALL relevant files completely before making changes**

````markdown
## File Analysis Protocol

**FOR EACH SUBTASK:**

1. **Read Complete Source Files**: Never work with partial file understanding
2. **Identify Business Logic**: Extract valuable functionality that must be preserved
3. **Map Dependencies**: Understand all service relationships and imports
4. **Review Existing Patterns**: Study how current code is structured
5. **Plan Preservation Strategy**: How to maintain valuable functionality

**EXAMPLE: Before splitting large service**

```typescript
// MUST READ COMPLETE FILE: code-review-delegation-template-data.service.ts
interface FileAnalysis {
  totalLines: 894;
  businessLogic: {
    delegationAnalytics: {
      lines: [123, 189, 245, 298, 456, 523];
      functions: ['calculateHandoffTime', 'analyzeRedelegationPatterns'];
      dependencies: ['ReportDataAccessService', 'CoreMetricsService'];
    };
    codeReviewInsights: {
      lines: [67, 122, 334, 398, 598, 654];
      functions: ['calculateReviewQuality', 'analyzeApprovalRates'];
      dependencies: ['ReportDataAccessService', 'ReviewMetricsService'];
    };
  };
  preservationPlan: {
    delegationService: 'Extract functions [list] with dependencies [list]';
    codeReviewService: 'Extract functions [list] with dependencies [list]';
  };
}
```
````

### Step 2.5: Enhanced Implementation Execution with Architectural Alignment (No MCP calls)

**Phase 2.5.1: Pattern-Driven Implementation**

**Follow architectural patterns exactly with validation:**

```typescript
// PATTERN: task-summary-data-api.service.ts (PROVEN REFERENCE)
// IMPLEMENTATION: delegation-analytics-data-api.service.ts (NEW SERVICE)

@Injectable()
export class DelegationAnalyticsDataApiService
  implements DelegationAnalyticsDataService
{
  private readonly logger = new Logger(DelegationAnalyticsDataApiService.name);

  constructor(
    private readonly reportDataAccess: ReportDataAccessService, // PATTERN: Use foundation service
  ) {}

  /**
   * PATTERN: Main service method follows exact structure from task-summary-data-api
   */
  async getDelegationAnalyticsData(
    startDate: Date,
    endDate: Date,
    filters?: Record<string, string>,
  ): Promise<DelegationAnalyticsTemplateData> {
    // PATTERN: Log with service name
    this.logger.debug(
      'Generating delegation analytics with focused business logic',
    );

    // PATTERN: Build where clause using foundation service
    const whereClause = this.reportDataAccess.buildWhereClause(
      startDate,
      endDate,
      filters as any,
    );

    // PATTERN: Get base metrics using foundation service
    const baseMetrics = await this.reportDataAccess.getBaseMetrics(whereClause);

    // FOCUSED BUSINESS LOGIC: Apply delegation-specific transformations
    const delegationMetrics = this.generateDelegationMetrics(baseMetrics);
    const roleEfficiency = this.calculateRoleEfficiency(baseMetrics);
    const bottlenecks = this.analyzeWorkflowBottlenecks(baseMetrics);

    // PATTERN: Return template-ready data structure
    return {
      generatedAt: new Date(),
      dateRange: {
        start: startDate.toISOString().split('T')[0],
        end: endDate.toISOString().split('T')[0],
      },
      reportType: 'delegation_analytics',
      data: {
        metrics: delegationMetrics,
        roleEfficiency,
        bottlenecks,
      },
    };
  }

  // PRIVATE METHODS: Focused business logic for delegation analytics only
  private generateDelegationMetrics(baseMetrics: any): DelegationMetrics {
    // Implementation extracted from original service lines 123-189, 245-298, 456-523
  }

  private calculateRoleEfficiency(baseMetrics: any): RoleEfficiencyData {
    // Implementation extracted from original service
  }

  private analyzeWorkflowBottlenecks(baseMetrics: any): BottleneckData[] {
    // Implementation extracted from original service
  }
}
```

**VALIDATION CHECKPOINTS DURING IMPLEMENTATION:**

```markdown
✅ **Pattern Adherence**: Does structure match task-summary-data-api.service.ts exactly?
✅ **Size Constraint**: Is service staying under 200 lines?
✅ **Single Responsibility**: Does service have one clear, focused purpose?
✅ **Business Logic Preservation**: Is valuable functionality from original service preserved?
✅ **Quality Maintenance**: Are coding standards and patterns maintained?
✅ **Interface Compatibility**: Will templates continue to work without changes?
```

**Phase 2.5.2: Continuous Validation During Implementation**

**MANDATORY: Validate at every step, not just at the end**

```typescript
interface ImplementationCheckpoint {
  step: string;
  validation: string[];
  qualityGate: boolean;
  nextAction: string;
}

// EXAMPLE CHECKPOINTS:
const checkpoints: ImplementationCheckpoint[] = [
  {
    step: 'File structure created',
    validation: [
      'Service class created with correct naming',
      'Constructor follows dependency injection pattern',
      'Main method signature matches interface',
      'Logger properly configured',
    ],
    qualityGate: true,
    nextAction: 'Begin business logic extraction',
  },
  {
    step: 'Business logic extracted',
    validation: [
      'Valuable functions identified and extracted',
      'Dependencies properly imported',
      'Private methods follow single responsibility',
      'No duplicate code between new services',
    ],
    qualityGate: true,
    nextAction: 'Create tests and validate functionality',
  },
  {
    step: 'Service completed',
    validation: [
      'Service under 200 lines',
      'All tests passing with 90%+ coverage',
      'Interface compatibility maintained',
      'Performance under 200ms response time',
      'No linting errors or warnings',
    ],
    qualityGate: true,
    nextAction: 'Proceed to next subtask',
  },
];
```

### Step 6.5: Enhanced Quality Validation with Architectural Compliance (No MCP calls)

**Phase 6.5.1: Architectural Compliance Validation**

**MANDATORY: Validate implementation against architectural guidance**

```markdown
## Architectural Compliance Checklist

**PATTERN ADHERENCE:**
✅ All services follow task-summary-data-api.service.ts pattern exactly
✅ Dependency injection properly implemented with foundation services
✅ Method signatures match interface specifications
✅ Error handling and logging consistent with established patterns

**QUALITY CONSTRAINTS:**
✅ All services under 200 lines (actual line count documented)
✅ Single responsibility principle maintained (each service has one clear purpose)
✅ Business logic properly focused (no overlap between services)
✅ Performance targets met (<200ms response time validated)

**BUSINESS LOGIC PRESERVATION:**
✅ All valuable functionality from original services preserved
✅ No duplicate logic between new services
✅ Template compatibility maintained (all existing functionality works)
✅ Data integrity preserved (same outputs for same inputs)

**INTEGRATION COMPLIANCE:**
✅ All service dependencies properly configured
✅ Module imports and exports updated correctly
✅ Interface implementations complete and correct
✅ Database queries and data access patterns maintained
```

**Phase 6.5.2: Implementation Quality Gates**

**MANDATORY: All quality gates must pass before considering subtask complete**

```typescript
interface QualityGate {
  category: string;
  requirements: string[];
  validationMethod: string;
  passingCriteria: string;
  status: 'passing' | 'failing' | 'not-tested';
}

const qualityGates: QualityGate[] = [
  {
    category: 'Code Quality',
    requirements: [
      'Service under 200 lines',
      'No linting errors or warnings',
      'All methods have clear business purpose',
      'Proper error handling implemented',
    ],
    validationMethod: 'Static analysis and code review',
    passingCriteria: 'All requirements met',
    status: 'not-tested',
  },
  {
    category: 'Functionality',
    requirements: [
      'All business logic preserved from original service',
      'Template compatibility maintained',
      'Same outputs for same inputs',
      'No regression in existing functionality',
    ],
    validationMethod: 'Integration testing and output comparison',
    passingCriteria: 'All functionality preserved, no regressions',
    status: 'not-tested',
  },
  {
    category: 'Performance',
    requirements: [
      'Response time under 200ms',
      'Memory usage within acceptable limits',
      'No performance degradation from original',
      'Database query efficiency maintained',
    ],
    validationMethod: 'Performance testing and profiling',
    passingCriteria: 'All performance targets met',
    status: 'not-tested',
  },
  {
    category: 'Testing',
    requirements: [
      'Unit tests for all business logic',
      'Integration tests for service interfaces',
      '90%+ test coverage achieved',
      'All tests passing consistently',
    ],
    validationMethod: 'Test execution and coverage analysis',
    passingCriteria: 'All tests passing, coverage target met',
    status: 'not-tested',
  },
];
```

### Step 8.5: Enhanced Git Operations with Architectural Context (No MCP calls)

**Phase 8.5.1: Architecture-Aware Commit Messages**

**CRITICAL: Commit messages must reflect architectural decisions and rationale**

```bash
# ENHANCED COMMIT MESSAGE STRUCTURE
COMMIT_MSG="refactor(architecture): Split delegation service following architectural guidance

Architectural Context:
- Split code-review-delegation-template-data.service.ts (894 lines) into focused services
- Target: delegation-analytics-data-api.service.ts (178 lines)
- Target: code-review-insights-data-api.service.ts (165 lines)
- Pattern: Following task-summary-data-api.service.ts proven structure

Business Logic Preserved:
- Delegation analytics: Role transitions, handoff times, redelegation patterns
- Code review insights: Review quality, approval rates, time analysis
- All template functionality maintained with interface compatibility

Quality Compliance:
✅ Both services under 200 lines (architectural constraint)
✅ Single responsibility principle maintained
✅ 92% test coverage (exceeds 90% target)
✅ Performance validated (<180ms average response time)
✅ All integration tests passing

Architectural Impact:
- Reduces service complexity and improves maintainability
- Eliminates code duplication and improves separation of concerns
- Enables independent evolution of delegation vs code review analytics
- Follows established architectural patterns for consistency

Files: 1 deleted, 2 created, 3 tests updated"

git commit -m "$COMMIT_MSG"
```

**Phase 8.5.2: Architectural Progress Tracking**

```markdown
## Implementation Progress Tracking

**ARCHITECTURAL MILESTONE TRACKING:**

- [ ] Service inventory and analysis completed
- [ ] Over-engineered services eliminated (8 analytics services)
- [ ] Large services split into focused components (2 major splits)
- [ ] All services comply with size constraints (<200 lines)
- [ ] Pattern adherence verified (task-summary-data-api structure)
- [ ] Business logic preservation validated
- [ ] Integration compatibility confirmed
- [ ] Quality gates passed for all new services

**CURRENT STATUS:**

- Services eliminated: 8/8 (analytics folder deleted)
- Services refactored: 2/3 (delegation service split complete)
- Pattern compliance: 100% (all services follow proven structure)
- Size compliance: 100% (all services under 200 lines)
- Quality gates: 85% passing (performance validation pending)
```

## Enhanced Success Criteria

### Architectural Guidance Consumption Excellence:

- **Complete Context Understanding**: All architectural decisions and rationale clearly understood ✓
- **Pattern Adherence Validation**: Implementation exactly follows proven patterns with validation ✓
- **Quality Constraint Compliance**: All services meet size, performance, and quality requirements ✓
- **Business Logic Preservation**: Valuable functionality maintained while eliminating complexity ✓
- **Continuous Validation**: Quality gates validated at every implementation step ✓

### Implementation Excellence with Architectural Alignment:

- **File-Level Precision**: Implementation exactly matches architectural file specifications ✓
- **Pattern-Driven Development**: Proven patterns followed exactly with validation checkpoints ✓
- **Quality-First Approach**: Quality gates validated throughout implementation, not just at end ✓
- **Architecture-Aware Commits**: Commit messages reflect architectural context and decisions ✓
- **Milestone Tracking**: Progress tracked against architectural targets and constraints ✓

### Senior Developer Empowerment Validation:

- **Comprehensive Guidance Consumption**: All architectural context successfully extracted and applied ✓
- **Implementation Confidence**: Clear understanding of what, why, and how for each subtask ✓
- **Quality Assurance Integration**: Quality validation integrated throughout implementation process ✓
- **Architectural Alignment**: Implementation decisions align with and support target architecture ✓
- **Delivery Excellence**: All deliverables meet architectural standards and business requirements ✓
