// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Model definitions based on 00-mcp-data-base-schema.md

model Task {
  taskId            String    @id // Corresponds to task_id TEXT PRIMARY KEY
  name              String
  status            String // 'Not Started', 'In Progress', 'In Review', 'Completed'
  creationDate      DateTime  @default(now())
  completionDate    DateTime?
  owner             String?
  currentMode       String?
  priority          String? // 'Low', 'Medium', 'High', 'Critical'
  dependencies      Json? // JSON array of task_ids
  redelegationCount Int       @default(0)
  gitBranch         String?

  taskDescription     TaskDescription?
  implementationPlans ImplementationPlan[]
  subtasks            Subtask[]
  delegationRecords   DelegationRecord[]
  researchReports     ResearchReport[]
  codeReviews         CodeReview[]
  completionReports   CompletionReport[]
  comments            Comment[]
  workflowTransitions WorkflowTransition[]
  codebaseAnalysis    CodebaseAnalysis?
  // @@map("tasks") // If table name in DB should be 'tasks'

  @@index([status])
  @@index([currentMode])
}

model TaskDescription {
  taskId                String   @id
  description           String
  businessRequirements  String
  technicalRequirements String
  acceptanceCriteria    Json // JSON array of acceptance criteria
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  task Task @relation(fields: [taskId], references: [taskId])

  // @@fulltext([description, businessRequirements, technicalRequirements]) // Prisma's representation of FTS - Removed due to connector incompatibility
  // @@map("task_descriptions")
}

model ImplementationPlan {
  id                 Int      @id @default(autoincrement())
  taskId             String
  overview           String
  approach           String
  technicalDecisions String
  filesToModify      Json // JSON array of files to modify
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  createdBy          String

  task     Task      @relation(fields: [taskId], references: [taskId])
  subtasks Subtask[]

  // @@map("implementation_plans")
}

model Subtask {
  id                Int       @id @default(autoincrement())
  taskId            String
  planId            Int
  name              String
  description       String
  sequenceNumber    Int
  status            String
  assignedTo        String?
  estimatedDuration String?
  startedAt         DateTime?
  completedAt       DateTime?
  batchId           String? // Added for batch information
  batchTitle        String? // Added for batch information

  task              Task               @relation(fields: [taskId], references: [taskId])
  plan              ImplementationPlan @relation(fields: [planId], references: [id])
  delegationRecords DelegationRecord[]
  comments          Comment[]
  // @@map("subtasks")

  @@index([taskId])
  @@index([status])
}

model DelegationRecord {
  id                  Int       @id @default(autoincrement())
  taskId              String
  subtaskId           Int?
  fromMode            String
  toMode              String
  delegationTimestamp DateTime  @default(now())
  completionTimestamp DateTime?
  success             Boolean?
  rejectionReason     String?
  redelegationCount   Int       @default(0)

  task    Task     @relation(fields: [taskId], references: [taskId])
  subtask Subtask? @relation(fields: [subtaskId], references: [id])
  // @@map("delegation_records")

  @@index([taskId])
  @@index([fromMode, toMode])
}

model ResearchReport {
  id              Int      @id @default(autoincrement())
  taskId          String
  title           String
  summary         String
  findings        String
  recommendations String
  references      Json // JSON array of references
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  task Task @relation(fields: [taskId], references: [taskId])

  // @@map("research_reports")
}

model CodeReview {
  id                             Int      @id @default(autoincrement())
  taskId                         String
  status                         String // 'APPROVED', 'APPROVED WITH RESERVATIONS', 'NEEDS CHANGES'
  summary                        String
  strengths                      String
  issues                         String
  acceptanceCriteriaVerification Json
  manualTestingResults           String
  requiredChanges                String?
  createdAt                      DateTime @default(now())
  updatedAt                      DateTime @updatedAt

  task Task @relation(fields: [taskId], references: [taskId])

  // @@map("code_reviews")
}

model CompletionReport {
  id                             Int      @id @default(autoincrement())
  taskId                         String
  summary                        String
  filesModified                  Json // JSON array of files modified
  delegationSummary              String
  acceptanceCriteriaVerification Json
  createdAt                      DateTime @default(now())

  task Task @relation(fields: [taskId], references: [taskId])

  // @@map("completion_reports")
}

model Comment {
  id        Int      @id @default(autoincrement())
  taskId    String
  subtaskId Int?
  mode      String
  content   String
  createdAt DateTime @default(now())

  task    Task     @relation(fields: [taskId], references: [taskId])
  subtask Subtask? @relation(fields: [subtaskId], references: [id])

  // @@map("comments")
}

model WorkflowTransition {
  id                  Int      @id @default(autoincrement())
  taskId              String
  fromMode            String
  toMode              String
  transitionTimestamp DateTime @default(now())
  reason              String?

  task Task @relation(fields: [taskId], references: [taskId])

  // @@map("workflow_transitions")
}

// CodebaseAnalysis model for storing structured codebase analysis results
// Critical for maintaining consistency across roles and preventing re-analysis
model CodebaseAnalysis {
  id     Int    @id @default(autoincrement())
  taskId String @unique

  // Analysis Content - JSON fields for structured data
  architectureFindings  Json // Current patterns, tech stack, file structure, dependencies
  problemsIdentified    Json // Issues found, root causes, impact assessment, technical debt
  implementationContext Json // Existing patterns, coding standards, quality guidelines
  integrationPoints     Json // API boundaries, service interfaces, external dependencies
  qualityAssessment     Json // Code quality metrics, testing coverage, documentation state

  // Additional Context
  filesCovered    Json // Array of files analyzed with their roles and importance
  technologyStack Json // Detailed tech stack with versions and usage patterns

  // Metadata
  analyzedAt      DateTime @default(now())
  updatedAt       DateTime @updatedAt
  analyzedBy      String // Role that performed the analysis (boomerang, architect, etc.)
  analysisVersion String   @default("1.0") // For tracking analysis evolution

  task Task @relation(fields: [taskId], references: [taskId])
  // @@map("codebase_analysis")

  @@index([taskId])
  @@index([analyzedBy])
}
